# name: test/sql/read_lines.test
# description: Test read_lines extension
# group: [sql]

# Before we load the extension, this will fail
statement error
SELECT * FROM read_text_lines('test.txt');
----
Catalog Error: Table Function with name read_text_lines does not exist!

# Require statement will ensure this test is run with this extension loaded
require read_lines

# Test parse_text_lines with simple input
# Use rtrim to strip line endings for easier test comparison
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3');
----
1	line1	0
2	line2	6
3	line3	12

# Test parse_text_lines with line selection - single line
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3', lines := 2);
----
2	line2	6

# Test parse_text_lines with line selection - range
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3\nline4\nline5', lines := '2-4');
----
2	line2	6
3	line3	12
4	line4	18

# Test parse_text_lines with line selection - list
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3\nline4\nline5', lines := [1, 3, 5]);
----
1	line1	0
3	line3	12
5	line5	24

# Test parse_text_lines with context
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3\nline4\nline5', lines := 3, context := 1);
----
2	line2	6
3	line3	12
4	line4	18

# Test parse_text_lines with before/after
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3\nline4\nline5', lines := 3, before := 1, after := 2);
----
2	line2	6
3	line3	12
4	line4	18
5	line5	24

# Test empty input
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines('');
----

# Test single line without newline
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines('single line');
----
1	single line	0

# Test Windows-style line endings (content preserves \r\n, we strip for comparison)
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\r\nline2\r\nline3');
----
1	line1	0
2	line2	7
3	line3	14

# Test mixed line endings
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\r\nline3\rline4');
----
1	line1	0
2	line2	6
3	line3	13
4	line4	19

# Verify line endings are actually preserved in content
query I
SELECT length(content) FROM parse_text_lines(E'ab\ncd') WHERE line_number = 1;
----
3

# Test line range with string list (ranges only)
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'a\nb\nc\nd\ne\nf\ng\nh\ni\nj', lines := ['1', '3-5', '8']);
----
1	a	0
3	c	4
4	d	6
5	e	8
8	h	14

# =============================================================================
# read_text_lines file-based tests
# =============================================================================

# Test reading a simple file
query IIII
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset, file_path LIKE '%simple.txt'
FROM read_text_lines('test/data/simple.txt');
----
1	line one	0	true
2	line two	9	true
3	line three	18	true
4	line four	29	true
5	line five	39	true

# Test reading specific lines from file
query II
SELECT line_number, rtrim(content, chr(10) || chr(13))
FROM read_text_lines('test/data/simple.txt', lines := '2-4');
----
2	line two
3	line three
4	line four

# Test reading single line from file
query II
SELECT line_number, rtrim(content, chr(10) || chr(13))
FROM read_text_lines('test/data/simple.txt', lines := 3);
----
3	line three

# Test file with no trailing newline
query II
SELECT line_number, rtrim(content, chr(10) || chr(13))
FROM read_text_lines('test/data/no_trailing_newline.txt');
----
1	first
2	second
3	third

# Test empty file
query II
SELECT line_number, rtrim(content, chr(10) || chr(13))
FROM read_text_lines('test/data/empty.txt');
----

# Test single line file
query II
SELECT line_number, rtrim(content, chr(10) || chr(13))
FROM read_text_lines('test/data/single_line.txt');
----
1	only one line

# Test glob pattern - multiple files
query II
SELECT line_number, rtrim(content, chr(10) || chr(13))
FROM read_text_lines('test/data/log*.txt')
WHERE content LIKE '%ERROR%'
ORDER BY file_path, line_number;
----
3	2024-01-01 ERROR Failed to connect
3	2024-01-02 ERROR Out of memory

# Test glob pattern - count lines per file
query II
SELECT file_path LIKE '%log1.txt' AS is_log1, count(*)
FROM read_text_lines('test/data/log*.txt')
GROUP BY file_path
ORDER BY file_path;
----
true	5
false	3

# Test context with file
query II
SELECT line_number, rtrim(content, chr(10) || chr(13))
FROM read_text_lines('test/data/simple.txt', lines := 3, context := 1);
----
2	line two
3	line three
4	line four

# Test reading lines with list selection from file
query II
SELECT line_number, rtrim(content, chr(10) || chr(13))
FROM read_text_lines('test/data/simple.txt', lines := [1, 3, 5]);
----
1	line one
3	line three
5	line five

# Test nonexistent file returns empty (glob with no matches)
query I
SELECT count(*) FROM read_text_lines('nonexistent_file_pattern_*.txt');
----
0

# Test ignore_errors parameter exists and works
query I
SELECT count(*)
FROM read_text_lines('test/data/simple.txt', ignore_errors := true);
----
5

# =============================================================================
# read_text_lines_lateral tests (for lateral join support)
# =============================================================================

# Test basic lateral join with VALUES
query III
SELECT v.path, l.line_number, rtrim(l.content, chr(10) || chr(13))
FROM (VALUES ('test/data/single_line.txt')) AS v(path),
     read_text_lines_lateral(v.path) AS l;
----
test/data/single_line.txt	1	only one line

# Test lateral join with multiple files
query II
SELECT v.path LIKE '%log1%' AS is_log1, count(*)
FROM (VALUES ('test/data/log1.txt'), ('test/data/log2.txt')) AS v(path),
     read_text_lines_lateral(v.path) AS l
GROUP BY v.path
ORDER BY v.path;
----
true	5
false	3
