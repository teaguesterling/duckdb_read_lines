# name: test/sql/read_lines.test
# description: Test read_lines extension
# group: [sql]

# Before we load the extension, this will fail
statement error
SELECT * FROM read_text_lines('test.txt');
----
Catalog Error: Table Function with name read_text_lines does not exist!

# Require statement will ensure this test is run with this extension loaded
require read_lines

# Test parse_text_lines with simple input
# Use rtrim to strip line endings for easier test comparison
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3');
----
1	line1	0
2	line2	6
3	line3	12

# Test parse_text_lines with line selection - single line
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3', lines := 2);
----
2	line2	6

# Test parse_text_lines with line selection - range
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3\nline4\nline5', lines := '2-4');
----
2	line2	6
3	line3	12
4	line4	18

# Test parse_text_lines with line selection - list
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3\nline4\nline5', lines := [1, 3, 5]);
----
1	line1	0
3	line3	12
5	line5	24

# Test parse_text_lines with context
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3\nline4\nline5', lines := 3, context := 1);
----
2	line2	6
3	line3	12
4	line4	18

# Test parse_text_lines with before/after
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\nline3\nline4\nline5', lines := 3, before := 1, after := 2);
----
2	line2	6
3	line3	12
4	line4	18
5	line5	24

# Test empty input
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines('');
----

# Test single line without newline
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines('single line');
----
1	single line	0

# Test Windows-style line endings (content preserves \r\n, we strip for comparison)
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\r\nline2\r\nline3');
----
1	line1	0
2	line2	7
3	line3	14

# Test mixed line endings
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'line1\nline2\r\nline3\rline4');
----
1	line1	0
2	line2	6
3	line3	13
4	line4	19

# Verify line endings are actually preserved in content
query I
SELECT length(content) FROM parse_text_lines(E'ab\ncd') WHERE line_number = 1;
----
3

# Test line range with string list (ranges only)
query III
SELECT line_number, rtrim(content, chr(10) || chr(13)), byte_offset FROM parse_text_lines(E'a\nb\nc\nd\ne\nf\ng\nh\ni\nj', lines := ['1', '3-5', '8']);
----
1	a	0
3	c	4
4	d	6
5	e	8
8	h	14
